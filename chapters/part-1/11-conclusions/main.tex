\chapter{Conclusion}
\label{ch:p1:conclusions}

\dictum[Famous code comment by Paul DiLascia]{%
  If this code works, it was written by Paul DiLascia. If not, I don't know who wrote it. }%
\vskip 1em

\readit{1}

\worktodo{
Conclusions
* reflect on Goals and what was achieved
* emphasize impact
* limitations, challenges, Lessons Learned 
* transition to next part
* synthesis, no restatement
* 1-2 pages
* lays groundwork 
}

\tldr{lay groundwork, offloading heavy lifting}
The main goal of this project was to enable the \RCstar collaboration to run the observable evaluation part of dynamic QCD+QED simulations on GPU-accelerated computing centers.
Offloading of the heavy-lifting parts -- repeated solves of the Dirac equation -- was the focus of the developments in particular, since it represents the most expensive kernel of lattice simulations.
This work marks by no means the end of the story; the above implementations merely lay crucial foundation for ongoing software developments.

\tldr{enabled more funding, compute allocations}
As a direct outcome, this work enabled the collaboration to acquire substantial compute allocations at leading supercomputing facilities, advancing the collaboration's physics programme and securing a second round of funding~\cite{online:pasc2025}.
Future work, including support for configuration generation and unified field treatment (\cref{ch:p1:memory}), builds directly upon the developments established here.
%However, it made it possible to acquire large compute budgets at super-computing centers advancing the collaborations physics programme to next step and secured a second round of funding for future developments concerning configuration generation and a unified field treatment as outlined in \cref{ch:p1:memory}.

\tldr{cicd, easy integration}
The \openqxd package now interfaces seamlessly with solver kernels provided by \quda, offering flexible and abstracted integration that reduces the complexity for application-level developers.
%The software package \openqxd is now able to interface all solver kernels from \quda in versatile forms, where implementation details are abstracted away for the programmer of \openqxd.
Existing tools can benefit from the improvements with low implementation effort.
Code robustness and stability was improved by introducing an automated CI/CD pipeline.

\tldr{scientific software is hard to do right}
Writing scientific software is challenging and can be as frustrating as it is rewarding.
%Every concept we know from industry software engineering is harder when considering scientific software development and needs more work: testing, readability, maintainability, complexity, scalability to just name a few.
Practices common in industry -- such as modular design, code readability, testing, deployment, and scalability -- require significantly more effort to achieve in the context of scientific computing.
However, that does not temper the satisfaction one feels when a piece of code finally works or a tenfold speedup was achieved.

\tldr{testing is pain, on real-world problems}
Testing scientific software is not straightforward.
One lesson learned was that testing should reflect production use cases ideally running on the target system using target parameters and target problem sizes, as opposed to a single local workstation on toy problems.
But, due to its parallel nature and utilization of multi-threading, multi-processing, CPUs, GPUs and being cutting edge in hardware and software developments, systematic testing of scientific software is more essential than ever.
This is particularly true when we compute observables for which no independent validation exists yet.
In such cases, trust in the software must be earned through rigorous and reproducible validation workflows.

\tldr{transition to part 2}
In the next part, we will approach the problem of efficient utilization of computational resources from an orthogonal perspective: through algorithmic development informed by physical insight.
The goal is to improve the estimation of physical observables not merely by accelerating code, but by enhancing the efficiency of the simulations themselves.
%It will deal with algorithmic developments backed by physical insight to obtain better estimates of physical observables.

